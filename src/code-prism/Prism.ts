import crypto from 'crypto'

import { PubSub, SubscribeType } from './PrismManager'

/**
 * Generates a universally unique identifier (UUID).
 *
 * This function uses the `crypto` module to generate a random 16-byte value
 * and returns it as a hexadecimal string.
 *
 * @returns {string} A randomly generated UUID in hexadecimal format.
 */
export function uuid(): string {
  return crypto.randomBytes(16).toString('hex')
}

/**
 * Prismì€ íŒŒì¼ í•˜ë‚˜ë‹¹ í•˜ë‚˜ì”© ì¡´ì¬í•˜ë©°, ì—¬ëŸ¬ ê°œì˜ Issueë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
 * IssueëŠ” íŒŒì¼ ë‚´ì˜ íŠ¹ì • ìœ„ì¹˜ì™€ ì—°ê²°ë˜ì–´ì§€ë©° í•´ë‹¹ ìœ„ì¹˜ì— ëŒ€í•œ ë‹¤ìˆ˜ì˜ ì •ë³´(Note)ë¥¼ ë‹´ê³  ìˆë‹¤.
 * Noteì€ ë‹¨ì¼ ì •ë³´ë¥¼ ì˜ë¯¸í•˜ë©° í…ìŠ¤íŠ¸ì™€ Linkë“±ìœ¼ë¡œ í•˜ë‚˜ì˜ ì •ë³´ë¥¼ í‘œí˜„í•œë‹¤.
 *
 * @remarks
 * Prism ê°œì²´ëŠ” `new Prism()`ìœ¼ë¡œ ìƒì„±í•˜ë©´ ì•ˆëœë‹¤.
 * `PrismManager.createPrismAndFile()`ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
 *
 * @class
 * @property {string} ver - The version of the Prism.
 * @property {string} name - The name of the Prism.
 * @property {Issue[]} issues - The collection of issues.
 */
export class Prism {
  // Prism, Issue, Noteì— ë³€ê²½ ì‚¬í•­ì„ ë°œìƒí•˜ë©´ PubSubì„ ì´ìš©í•˜ì—¬ subscriberì—ê²Œ ë³€ê²½ ì‚¬í•­ì„ ì „ë‹¬í•œë‹¤
  // publish-subscribeì˜ ì„¤ì •ì€ PrismManagerë¥¼ í†µí•´ì„œ ì„¤ì •í•˜ë©° Prism ê°œì²´ëŠ” ë‹¨ì§€ PrismManagerì˜
  // ì„¤ì •ê°’ì„ ì‚¬ìš©í•  ë¿ì´ë‹¤. Prismì˜ pubSub ì„¤ì •ë„ PrismManagerê°€ Prism ìƒì„± í›„ ì„¤ì •í•´ ì¤€ë‹¤.
  private pubSub?: PubSub<SubscribeType>
  setPubSub(pubSub: PubSub<SubscribeType>): void {
    this.pubSub = pubSub
  }

  ver: string = '1.0.0'
  name: string = ''
  issues: Issue[] = []

  /**
   * Constructs a new instance of the Prism class.
   *
   * @param json - An optional parameter that can be used to initialize the instance properties.
   * @param json.ver - The version of the prism.
   * @param json.name - The name of the prism.
   * @param json.issues - Additional issues about the prism.
   */
  constructor(json?: any) {
    if (json) {
      this.ver = json.ver
      this.name = json.name
      this.issues = (json.issues || []).map((issueJson: any) => {
        const issue = new Issue()
        issue.fromJSON(issueJson)
        return issue
      })
    }
  }

  /**
   * Converts the current object to a JSON representation.
   *
   * @returns {any} A JSON object containing the version, name, and issues of the current object.
   */
  toJSON(): any {
    return {
      '#': 'NOT recommend to edit manually. Write carefully! This file is generated by code-prism vscode extension.',
      ver: this.ver,
      name: this.name,
      issues: this.issues,
    }
  }

  /**
   * Converts the current object to a JSON string representation.
   *
   * @returns {string} A stringified JSON representation of the object.
   */
  toString(): string {
    return JSON.stringify(this, null, 2)
  }

  /**
   * Clears the issues array by setting it to an empty array.
   *
   * @remarks
   * This method is used to reset the issues stored in the instance.
   */
  clear(): void {
    this.issues = []
  }

  /**
   * Checks if the issues array is empty.
   *
   * @returns {boolean} `true` if the issues array is empty, otherwise `false`.
   */
  isEmpty(): boolean {
    return this.issues.length === 0
  }

  /**
   * Retrieves the count of issues.
   *
   * @returns {number} The number of issues.
   */
  getIssuesCount(): number {
    return this.issues.length
  }

  /**
   * Retrieves the list of issues.
   *
   * @returns {Issue[]} An array of Issue objects.
   */
  getIssues(): Issue[] {
    return this.issues
  }

  /**
   * Retrieves a issue by its unique identifier.
   *
   * @param id - The unique identifier of the issue to retrieve.
   * @returns The issue with the specified identifier, or `undefined` if no such issue exists.
   */
  getIssue(id: string): Issue | undefined {
    return this.issues.find(i => i.id === id)
  }

  /**
   * Retrieves a issue by its title.
   *
   * @param title - The title of the issue to retrieve.
   * @returns The issue with the specified title, or `undefined` if no such issue exists.
   */
  getIssueByTitle(title: string): Issue | undefined {
    return this.issues.find(i => i.title === title)
  }

  /**
   * Appends an issue to the list of issues if it does not already exist.
   * If the issue already exists, it returns the existing issue.
   *
   * @param issue - The issue to be appended.
   * @returns The appended issue or the existing issue if it already exists.
   */
  appendIssue(issue: Issue): Issue {
    const exist = this.getIssue(issue.id)
    if (exist) {
      return exist
    }

    issue.prism = this
    this.issues.push(issue)
    this.pubSub?.publish('append-issue', { prism: this, issue })
    return issue
  }

  /**
   * Removes a issue from the list of issues based on the provided title.
   *
   * @param issueId - The title of the issue to be removed.
   */
  removeIssue(issueId: string): void {
    const remove = this.getIssue(issueId)
    if (!remove) {
      return
    }

    this.issues = this.issues.filter(i => i.id !== issueId)
    this.pubSub?.publish('remove-issue', { prism: this, issue: remove })
  }

  /**
   * Appends a note to the specified issue.
   *
   * @param issueId - The ID of the issue to which the note will be appended.
   * @param note - The note to append to the issue.
   * @returns The appended note if the issue exists, otherwise `undefined`.
   */
  appendNote(issueId: string, note: Note): Note | undefined {
    const issue = this.getIssue(issueId)
    if (!issue) {
      return undefined
    }

    issue.notes.push(note)
    this.pubSub?.publish('append-note', { prism: this, issue, note })
    // console.log(`ğŸš€ ~ appendNote: ${issueId}, ${note.id}`)
    return note
  }

  /**
   * Updates the description of a issue with the given issueId.
   * If the issue or the description is not found, the method returns without making any changes.
   *
   * @param issueId - The unique identifier of the issue to update.
   * @param note - The new note to update in the issue.
   *
   * @remarks
   * This method publishes an 'update-note' event with the updated description if the update is successful.
   */
  updateNote(issueId: string, note: Note): void {
    const issue = this.getIssue(issueId)
    if (!issue) {
      return
    }

    const exist = issue.findNote(note.id)
    if (!exist) {
      return
    }

    Object.assign(exist, note)
    this.pubSub?.publish('update-note', { prism: this, issue, note })
    // console.log(`ğŸš€ ~ updateNote: ${issueId}, ${note.id}`)
  }

  /**
   * Removes a description from a issue by its ID.
   *
   * @param issueId - The ID of the issue from which the description will be removed.
   * @param noteId - The ID of the description to be removed.
   * @returns void
   */
  removeNote(issueId: string, noteId: string): void {
    const issue = this.getIssue(issueId)
    if (!issue) {
      return
    }

    let note = issue.notes.find(n => n.id === noteId)
    if (!note) {
      return
    }

    // noteì˜ ê²½ìš°ì—ëŠ” ì‚­ì œ í›„ issue.notesê°€ ë¹„ì–´ìˆìœ¼ë©´ í•´ë‹¹ issueë„ ì‚­ì œí•œë‹¤.
    issue.notes = issue?.notes.filter(n => n.id !== noteId)
    if (issue.notes.length === 0) {
      this.removeIssue(issueId)
    } else {
      this.pubSub?.publish('remove-note', { prism: this, issue, note })
      // console.log(`ğŸš€ ~ removeNote: ${issueId}, ${note.id}`)
    }
  }

  /**
   * Generates a default note object.
   *
   * @param content - An optional string to include in the note.
   * @returns A `Note` object with default values.
   */
  static getDefaultNote(content?: string): Note {
    return {
      id: uuid(),
      category: 'Todo',
      importance: 'Medium',
      createdAt: new Date().toISOString(),
      content: content ?? 'I have something to do',
    }
  }
}

/**
 * Represents an issue within the Prism system.
 */
export class Issue {
  id: string
  title: string
  source: Source
  notes: Note[] = []

  // Prism ê°œì²´ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ê°€ì§€ê³  ìˆëŠ”ë° JSONìœ¼ë¡œ ë³€í™˜í•  ë•ŒëŠ” ì œì™¸ë˜ê³  prismì— ì¶”ê°€ë  ë•Œ ì„¤ì •ëœë‹¤.
  prism?: Prism

  /**
   * Creates an instance of the Prism class.
   *
   * @param prism - An instance of the Prism class.
   * @param title - The title associated with the Prism instance.
   * @param source - The source object related to the Prism instance.
   */
  constructor(prism?: Prism, title?: string, source?: Source) {
    this.id = uuid()
    this.title = title ?? ''
    this.source = source ?? {
      file: '',
      startLine: 0,
      startColumn: 0,
      endLine: 0,
      endColumn: 0,
    }
    if (prism) {
      this.prism = prism
    }
  }

  /**
   * Populates the properties of the current instance with values from a JSON object.
   */
  fromJSON(json: any) {
    this.id = json.id
    this.title = json.title
    this.source = json.source
    this.notes = json.notes
  }

  /**
   * Converts the current object to a JSON representation.
   */
  toJSON(): any {
    return {
      id: this.id,
      title: this.title,
      source: this.source,
      notes: this.notes,
    }
  }

  /**
   * Finds a note by its unique identifier.
   *
   * @param noteId - The unique identifier of the note to find.
   * @returns The note with the specified identifier, or `undefined` if no such note exists.
   */
  findNote(noteId: string): Note | undefined {
    return this.notes.find(n => n.id === noteId)
  }
}

/**
 * Represents a source code location with optional links.
 *
 * @interface Source
 *
 * @property {string} file - The file path of the source code.
 * @property {number} startLine - The starting line number of the source code.
 * @property {number} startColumn - The starting column number of the source code.
 * @property {number} endLine - The ending line number of the source code.
 * @property {number} endColumn - The ending column number of the source code.
 * @property {string} [link] - An optional link associated with the source code.
 */
export interface Source {
  file: string
  startLine: number
  startColumn: number
  endLine: number
  endColumn: number
  link?: string
}

/**
 * Represents a note of a code entity.
 *
 * @interface Note
 *
 * @property {string} id - The unique identifier for the note.
 * @property {string} category - The category to which the note belongs.
 * @property {string} importance - The importance level of the note.
 * @property {string} createdAt - The date and time when the note was created.
 * @property {string} content - The content of the note.
 * @property {string} [link] - An optional link related to the note.
 */
export interface Note {
  id: string
  category: string
  importance: string
  createdAt: string
  content: string
  link?: string
}
