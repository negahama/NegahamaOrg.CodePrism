import * as vscode from 'vscode'
import crypto from 'crypto'

import { PubSub, SubscribeType } from './PrismManager'
import { PrismFileManager } from './PrismFileManager'

/**
 * Generates a universally unique identifier (UUID).
 *
 * This function uses the `crypto` module to generate a random 16-byte value
 * and returns it as a hexadecimal string.
 *
 * @returns {string} A randomly generated UUID in hexadecimal format.
 */
function uuid(): string {
  return crypto.randomBytes(16).toString('hex')
}

/**
 * Prismì€ íŒŒì¼ í•˜ë‚˜ë‹¹ í•˜ë‚˜ì”© ì¡´ì¬í•˜ë©°, ì—¬ëŸ¬ ê°œì˜ Issueë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
 * IssueëŠ” íŒŒì¼ ë‚´ì˜ íŠ¹ì • ìœ„ì¹˜ì™€ ì—°ê²°ë˜ì–´ì§€ë©° í•´ë‹¹ ìœ„ì¹˜ì— ëŒ€í•œ ë‹¤ìˆ˜ì˜ ì •ë³´(Note)ë¥¼ ë‹´ê³  ìˆë‹¤.
 * Noteì€ ë‹¨ì¼ ì •ë³´ë¥¼ ì˜ë¯¸í•˜ë©° í…ìŠ¤íŠ¸ì™€ Linkë“±ìœ¼ë¡œ í•˜ë‚˜ì˜ ì •ë³´ë¥¼ í‘œí˜„í•œë‹¤.
 *
 * @remarks
 * Prism ê°œì²´ëŠ” `new Prism()`ìœ¼ë¡œ ìƒì„±í•˜ë©´ ì•ˆëœë‹¤. `PrismManager.createPrism()`ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
 *
 * @class
 * @property {string} ver - The version of the Prism.
 * @property {string} name - The name of the Prism.
 * @property {Issue[]} issues - The collection of issues.
 */
export class Prism {
  // Prism, Issue, Noteì— ë³€ê²½ ì‚¬í•­ì„ ë°œìƒí•˜ë©´ PubSubì„ ì´ìš©í•˜ì—¬ subscriberì—ê²Œ ë³€ê²½ ì‚¬í•­ì„ ì „ë‹¬í•œë‹¤
  // publish-subscribeì˜ ì„¤ì •ì€ PrismManagerë¥¼ í†µí•´ì„œ ì„¤ì •í•˜ë©° Prism ê°œì²´ëŠ” ë‹¨ì§€ PrismManagerì˜
  // ì„¤ì •ê°’ì„ ì‚¬ìš©í•  ë¿ì´ë‹¤. Prismì˜ pubSub ì„¤ì •ë„ PrismManagerê°€ Prism ìƒì„± í›„ ì„¤ì •í•´ ì¤€ë‹¤.
  private pubSub?: PubSub<SubscribeType>
  setPubSub(pubSub: PubSub<SubscribeType>): void {
    this.pubSub = pubSub
  }

  ver: string = '1.0.0'
  name: string = ''
  issues: Issue[] = []

  /**
   * Constructs a new instance of the Prism class.
   *
   * @param json - An optional parameter that can be used to initialize the instance properties.
   * @param json.ver - The version of the prism.
   * @param json.name - The name of the prism.
   * @param json.issues - Additional issues about the prism.
   */
  constructor(json?: any) {
    if (json) {
      this.ver = json.ver
      this.name = json.name
      this.issues = json.issues
    }
  }

  /**
   * Converts the current object to a JSON representation.
   *
   * @returns {any} A JSON object containing the version, name, and issues of the current object.
   */
  toJson(): any {
    return {
      ver: this.ver,
      name: this.name,
      issues: this.issues,
    }
  }

  /**
   * Converts the current object to a JSON string representation.
   *
   * @returns {string} A stringified JSON representation of the object.
   */
  toString(): string {
    const json = {
      '#': 'NOT recommend to edit manually. Write carefully! This file is generated by code-prism vscode extension.',
      ver: this.ver,
      name: this.name,
      issues: this.issues,
    }
    return JSON.stringify(json, null, 2)
  }

  /**
   * Clears the issues array by setting it to an empty array.
   *
   * @remarks
   * This method is used to reset the issues stored in the instance.
   */
  clear(): void {
    this.issues = []
  }

  /**
   * Checks if the issues array is empty.
   *
   * @returns {boolean} `true` if the issues array is empty, otherwise `false`.
   */
  isEmpty(): boolean {
    return this.issues.length === 0
  }

  /**
   * Retrieves the count of issues.
   *
   * @returns {number} The number of issues.
   */
  getIssuesCount(): number {
    return this.issues.length
  }

  /**
   * Retrieves the list of issues.
   *
   * @returns {Issue[]} An array of Issue objects.
   */
  getIssues(): Issue[] {
    return this.issues
  }

  /**
   * Retrieves a issue by its unique identifier.
   *
   * @param id - The unique identifier of the issue to retrieve.
   * @returns The issue with the specified identifier, or `undefined` if no such issue exists.
   */
  getIssue(id: string): Issue | undefined {
    return this.issues.find(i => i.id === id)
  }

  /**
   * Retrieves a issue by its title.
   *
   * @param title - The title of the issue to retrieve.
   * @returns The issue with the specified title, or `undefined` if no such issue exists.
   */
  getIssueByTitle(title: string): Issue | undefined {
    return this.issues.find(i => i.title === title)
  }

  /**
   * Adds a issue to the list of issues.
   *
   * @param issue - The issue to be added.
   */
  appendIssue(issue: Issue): Issue {
    const exist = this.getIssue(issue.id)
    if (exist) {
      return exist
    }

    this.issues.push(issue)
    this.pubSub?.publish('append-issue', { prism: this, issue })
    return issue
  }

  /**
   * Appends issue details to the current issue collection.
   *
   * @param title - The title of the issue.
   * @param source - The source file path.
   * @param range - The range within the source file.
   *
   * The source file path is stored relative to the workspace root, which must start with a '/'.
   * The line and column numbers in the range are adjusted to be 1-based.
   */
  appendIssueDetails(title: string, source: string, range: vscode.Range): Issue {
    const issue: Issue = {
      id: uuid(),
      title,
      source: {
        // source fileì€ workspace root ê²½ë¡œë¡œ ì €ì¥í•œë‹¤.
        // ì´ë•Œ ë§ˆí¬ë‹¤ìš´ì—ì„œ workspace root ê²½ë¡œëŠ” ë°˜ë“œì‹œ / ë¡œ ì‹œì‘í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì—
        // CodePrism ì „ì²´ì—ì„œ workspace root ê²½ë¡œëŠ” ëª¨ë‘ / ë¡œ ì‹œì‘í•˜ë„ë¡ ì •í•´ì ¸ ìˆë‹¤.
        file: '/' + PrismFileManager.getRelativePath(source).replace(/\\/g, '/'),
        startLine: range.start.line + 1,
        startColumn: range.start.character,
        endLine: range.end.line + 1,
        endColumn: range.end.character,
      },
      notes: [],
    }

    this.appendIssue(issue)
    return issue
  }

  /**
   * Updates an existing issue by first removing the issue with the same title
   * and then adding the new issue.
   *
   * @param issue - The issue object to be updated.
   */
  updateIssue(issue: Issue): void {
    this.removeIssue(issue.id)
    this.appendIssue(issue)
  }

  /**
   * Removes a issue from the list of issues based on the provided title.
   *
   * @param issueId - The title of the issue to be removed.
   */
  removeIssue(issueId: string): void {
    const remove = this.getIssue(issueId)
    if (!remove) {
      return
    }

    this.issues = this.issues.filter(i => i.id !== issueId)
    this.pubSub?.publish('remove-issue', { prism: this, issue: remove })
  }

  /**
   * Appends a note to the specified issue.
   *
   * @param issueId - The ID of the issue to which the note will be appended.
   * @param note - The note to append to the issue.
   * @returns The appended note if the issue exists, otherwise `undefined`.
   */
  appendNote(issueId: string, note: Note): Note | undefined {
    const issue = this.getIssue(issueId)
    if (!issue) {
      return undefined
    }

    issue.notes.push(note)
    this.pubSub?.publish('append-note', { prism: this, issue, note })
    // console.log(`ğŸš€ ~ appendNote: ${issueId}, ${note.id}`)
    return note
  }

  /**
   * Updates the description of a issue with the given issueId.
   * If the issue or the description is not found, the method returns without making any changes.
   *
   * @param issueId - The unique identifier of the issue to update.
   * @param note - The new note to update in the issue.
   *
   * @remarks
   * This method publishes an 'update-note' event with the updated description if the update is successful.
   */
  updateNote(issueId: string, note: Note): void {
    const issue = this.getIssue(issueId)
    if (!issue) {
      return
    }

    const exist = issue.notes.find(n => n.id === note.id)
    if (!exist) {
      return
    }

    Object.assign(exist, note)
    this.pubSub?.publish('update-note', { prism: this, issue, note })
    // console.log(`ğŸš€ ~ updateNote: ${issueId}, ${note.id}`)
  }

  /**
   * Removes a description from a issue by its ID.
   *
   * @param issueId - The ID of the issue from which the description will be removed.
   * @param noteId - The ID of the description to be removed.
   * @returns void
   */
  removeNote(issueId: string, noteId: string): void {
    const issue = this.getIssue(issueId)
    if (!issue) {
      return
    }

    let note = issue.notes.find(n => n.id === noteId)
    if (!note) {
      return
    }

    issue.notes = issue?.notes.filter(n => n.id !== noteId)
    this.pubSub?.publish('remove-note', { prism: this, issue, note })
    // console.log(`ğŸš€ ~ removeNote: ${issueId}, ${note.id}`)
  }

  /**
   * Generates a default note object.
   *
   * @param content - An optional string to include in the note.
   * @returns A `Note` object with default values.
   */
  static getDefaultNote(content?: string): Note {
    return {
      id: uuid(),
      category: 'General',
      importance: 'Medium',
      createdAt: new Date().toISOString(),
      content: content ?? 'I have something to do',
    }
  }
}

/**
 * Represents a issue with an identifier, title, source, and notes.
 *
 * @interface Issue
 * @property {string} id - The unique identifier for the issue.
 * @property {string} title - The title of the issue.
 * @property {Source} source - The source information of the issue.
 * @property {Note[]} notes - An array of notes associated with the issue.
 */
export interface Issue {
  id: string
  title: string
  source: Source
  notes: Note[]
}

/**
 * Represents a source code location with optional links.
 *
 * @interface Source
 *
 * @property {string} file - The file path of the source code.
 * @property {number} startLine - The starting line number of the source code.
 * @property {number} startColumn - The starting column number of the source code.
 * @property {number} endLine - The ending line number of the source code.
 * @property {number} endColumn - The ending column number of the source code.
 * @property {string} [link] - An optional link associated with the source code.
 * @property {string} [link2] - An optional second link associated with the source code.
 */
export interface Source {
  file: string
  startLine: number
  startColumn: number
  endLine: number
  endColumn: number
  link?: string
  link2?: string
}

/**
 * Represents a note of a code entity.
 *
 * @interface Note
 *
 * @property {string} id - The unique identifier for the note.
 * @property {string} category - The category to which the note belongs.
 * @property {string} importance - The importance level of the note.
 * @property {string} createdAt - The date and time when the note was created.
 * @property {string} content - The content of the note.
 * @property {string} [link] - An optional link related to the note.
 * @property {string} [link2] - An optional second link related to the note.
 */
export interface Note {
  id: string
  category: string
  importance: string
  createdAt: string
  content: string
  link?: string
  link2?: string
}
